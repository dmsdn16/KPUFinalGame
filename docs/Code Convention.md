**C++ Style Guide**
=====
**배경**  
------
이 문서는 졸업작품 제작을 함에 있어서 코드 컨벤션을 사전에 지정함으로서 협업 중 혼선을 방지하는 것을 목표로 한다. 이 문서는 [Google C++ Style Guide](https://jongwook.kim/google-styleguide/trunk/cppguide.xml)를 참고해서 작성되었다.

**이름 규칙**
------
1. 일반 이름 규칙  
   *  함수 이름, 변수 이름, 파일 이름은 약어를 피하고 서술적으로 지어야 한다.
   *  가능하면 상세한 이름을 사용하라. 새로 읽는 사람이 즉시 이해할 수 있는 것이 글자 길이를 줄이는 것보다 훨씬 중요하다.
   *  프로젝트에 관계되지 않은 사람이 익숙하지 않은 약어를 사용하지 말고 중간 글자를 지워서 축약하지 말라.
2. 파일 이름
   * 파일 이름은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다.(CamelCased)  
    ex) MyUsefulClass.h, MyExcitingFunction.cpp
   * db.h와 같이 /usr/include에 이미 존재하는 파일 이름은 사용하지 말라.
   * 일반적으로 상세하게 파일 이름을 지으라.
    ex) HttpServerLogs.h가 logs.h보다 좋다.
   * 인라인 함수는 .h에 있어야 한다. 인라인 함수의 코드가 짧으면 .h안에 들어가고, 길다면 Inl.h로 가야한다. 클래스 안에 많은 인라인 코드가 있다면 3개의 파일로 분리한다. 
    ``` C++
    UrlTable.h          // 클래스 선언
    UrlTable.cpp        // 클래스 정의
    UrlTableInl.h       // 많은 코드를 포함한 인라인 함수
    ```
   * Inl.h 파일 섹션 참조
3. 타입 이름  
   * 타입 이름은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다.(CamelCased)  
    ex) MyExcitingClass, MyExcitingEnum
   * 클래스, 구조체, typedef, 열거형(enum)을 포함한 모든 타입에 대해 같은 규칙이 적용된다.
    ``` C++
    // 클래스와 구조체
    class UrlTable {...}
    class UrlTableProperties {...}
    struct UrlTableProperties {...}

    // typedef
    typedef hash_map<UrlTableProperties*, std::string> PropertiesMap;
    
    // 열거형(enum)
    enum UrlTableErrors {...}
    ```
4. 변수 이름  
    * 변수의 이름은 모두 소문자로 작성하며 단어 사이에 언더스코어를 사용한다.(under_scored)
    * 클래스 멤버 변수는 이름의 앞에 m_ 접두어를 사용한다.  
     ex) my_exciting_local_variable, m_my_exciting_member_variable  
   
    <u>공통사항</u>
    ``` C++
    std::string table_name; // 좋음 - 언더스코어를 사용한다.
    std::string tablename;  // 좋음 - 모두 소문자이다.

    std::string tableName;  // 불가 - 대문자 사용
    ```
    <u>클래스 데이터 멤버</u>  
    데이터 멤버(인스턴스 변수 또는 멤버 변수)의 이름은 보통 변수처럼 소문자와 선택적인 언더스코어로 작성하지만, 항상 앞에 m_ 접두어를 붙인다.
    ``` C++
    std::string m_table_name;   // 좋음 - 앞에 m_가 있다.
    std::string m_tablename;    // 좋음
    ```
    <u>구조체 변수</u>  
    구조체 안에 있는 데이터 멤버는 클래스에 있는 데이터 멤버와 다르게 앞에 m_ 접두어를 붙이지 않고 보통 변수처럼 이름짓는다.
    ``` C++
    struct UrlTableProperties
    {
        std::string name;
        int num_entries;
    }
    ```
    어떤 경우에 클래스와 구조체를 써야 할 지에 대해서는 구조체 대 클래스를 참고하라.  
    <u>전역 변수</u>
    * 제한적으로 사용되어야 하는 전역 변수의 이름에 대한 특별한 규칙은 없다. 하지만 전역 변수를 사용할 때에는 g_와 같이 로컬 변수와 쉽게 구분할 수 있는 접두어를 사용하는 것이 좋다.
5. 상수 이름
    * 지역변수인지, 전역변수인지, 클래스의 일부인지와 상관없이 모든 컴파일 시점 상수들은 다른 변수들과 조금 다른 이름 규칙을 사용한다. k로 시작하여 매 단어의 첫 글자를 대문자로 쓴다.(kCamelCased)
    ``` C++
    const int kDaysInWeek = 7;
    ```
6. 함수 이름  
    * 일반 함수들은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다. 접근자와 변경자는 해당하는 변수의 이름과 같은 것을 쓴다.(CamelCased)  
     ex) MyExcitingFunction(), MyExcitingMethod()  
    
    <u>일반 함수</u>  
      * 함수 이름은 대문자로 시작하여 각 단어의 첫 글자를 대문자로 쓰고, 언더스코어는 사용하지 않는다.
      * 함수의 실행 중 크래시가 발생할 수 있다면 함수의 이름 뒤에 OrDie를 붙인다. 이 규칙은 프로덕션 코드에서도 에러가 발생할 가능성이 어느 정도 있는 함수에 한해 적용한다.
    ``` C++
    AddTableEntry()
    DeleteUrl()
    OpenFileOrDie()
    ```

    <u>접근자와 변경자</u>  
      * 접근자와 변경자 (get과 set 함수)는 접근 또는 변경을 하려는 변수의 이름과 일치하는 이름을 사용한다.
    ``` C++
    class MyClass
    {
    public:
    ...
        int NumEntries() const { return m_num_entries; }
        void SetNumEntries(int num_entries) { m_num_entries = num_entries; }

    private:
        int m_num_entries;
    };
    ```
7. 네임스페이스 이름  
    * 네임스페이스 이름은 모두 소문자로 하며, 프로젝트의 이름과 아마도 디렉토리 구조에 기반하여 작성한다.(under_scored)
     ex) kpu_final_game
    * 네임스페이스와 네임스페이스의 이름을 짓는 방식에 대해선 네임스페이스 섹션 참고.
8. 열거형 이름
    * 각각의 열거형은 상수처럼 이름짓는 것이 선호되지만 매크로처럼 이름짓는 것도 허용한다. 열거형의 이름은 타입이므로 대소문자를 섞어서 사용한다.(kCamelCased or ALL_CAPITALS)
    ``` C++
    enum UrlTableErrors
    {
        kOK = 0,
        kErrorOutOfMemory,
        kErrorMalformedInput,
    };
    enum AlternateUrlTableErrors
    {
        OK = 0,
        OUT_OF_MEMORY = 1,
        MALFORMED_INPUT = 2,
    };
    ```
    * 매크로 방식은 매크로와 열거형 값의 충돌을 일으켰고, 상수 스타일의 이름을 선호하는 방식으로 규칙이 변경되었다.
    * 매크로 방식의 이름이 실제로 컴파일 오류를 발생시키는 것이 아니라면 코드를 상수 스타일 이름으로 수정할 필요는 없다.
9. 매크로 이름
    * 전처리기 매크로 섹션을 참고하라.
    * 일반적으로 매크로는 사용하지 않는 것이 좋다.
    * 하지만 절대적으로 필요하다면 대문자와 언더스코어로만 이름을 짓는다.(ALL_CAPITALS)
    ``` C++
    #define ROUND(X) ...
    #define PI_ROUNDED 3.0
    ```
10. 이름 규칙의 예외
     * 이미 존재하는 C 또는 C++ 엔티티와 비슷한 것의 이름을 짓는 경우 그 이름 규칙을 따를 수 있다.
    ``` C++
    bigopen()
        open()의 이름에 기반한 함수
    uint
        typedef
    bigpos
        pos와 같은 형식의 struct 또는 class
    sparse_hash_map
        STL과 유사한 엔티티이므로 STL의 이름 규칙을 따름
    LONGLONG_MAX
        INT_MAX와 비슷한 상수
    ```
**헤더 파일**
------
기본적으로 모든 .cpp 파일은 수반된 .h 파일을 가져야 한다. 흔한 예외로는 유닛 테스트나 main() 함수만을 가진 작은 .cpp 파일 등이 있다. 헤더 파일을 바르게 사용하는 것으로 코드의 가독성과 크기와 성능에 큰 차이를 만들 수 있다. 아래 규칙들은 헤더 파일을 사용할 때 피해야 할 함정들에 관한 가이드이다.
1. #define 가드
   * 모든 헤더 파일은 여러 번 포함되지 않기 위해 #define 가드를 사용해야 한다. 기호의 포맷은 <PROJECT>_<PATH>_<FILE>_H_ 으로 한다.
   * 유일성을 보장하기 위해 #define 가드는 프로젝트의 소스 트리의 절대 경로에 기반해야 한다. 예를 들어 프로젝트에 foo/src/bar/Baz.h 파일이 있다면 foo는 아래와 같은 가드를 가져야 한다.
    ``` C++
    #ifndef FOO_BAR_BAZ_H_
    #define FOO_BAR_BAZ_H_
    ...
    #endif  // FOO_BAR_BAZ_H_
    ```
   * 이를 대체하는 대체제로 #pragma once를 사용할 수 있지만 pragma 키워드는 Visual Studio에 종속적인 키워드라 다른 IDE에서 작동을 안 하므로 범용성을 보장하고자 하면 위와 같은 절차를 따르는 것이 좋다.
2. 전방 선언
   * 불필요한 #include를 피하기 위해 클래스를 전방 선언할 수도 있다.
   * 정의
        * "전방 선언"이란 수반되는 정의 없이 클래스나 함수, 템플릿을 선언하는 것이다. 클라이언트 코드에서 어떤 기호가 실제로 사용되든 #include 라인은 종종 전방 선언으로 대체할 수 있다.
   * 장점
        * 불필요한 #include는 컴파일러가 더 많은 파일을 열고 더 많은 입력을 처리하도록 만든다.
        * 불필요한 #include는 헤더 파일 변경 시 코드를 더 자주 다시 컴파일하도록 만든다.
   * 단점
        * 템플릿, typedef, 디폴트 인자, using 선언과 같은 기능을 쓸 때 전방 선언의 정확한 형태를 결정하기 힘들 수 있다.
        * 어떤 코드 조각에서는 전방 선언이 필요한지 전체 #include가 필요한지 결정하기 힘들 수 있다. 특히 암시적 변환이 개입될 때 그렇다. 극단적인 경우에는 #include를 전방 선언으로 대체하면 코드의 의미가 조용히 바뀔 수도 있다.
        * 헤더에서 여러 기호를 전방 선언하는 것은 단순히 헤더를 #include하는 것보다 장황해질 수 있다.
        * 호환성을 깨지 않고 헤더에서 할 수 있었던 변경들이 함수나 템플릿의 전방 선언 때문에 불가능해질 수 있다. 예를 들어 인자 타입을 더 넓은 타입으로 바꾼다거나, 디폴트 값이 있는 템플릿 인자를 추가하는 것 등이 그렇다.
        * std:: 네임스페이스의 기호를 전방 선언하면 보통 예상할 수 없는 결과를 유발한다.
        * 전방 선언이 가능하도록 코드를 구조화하는 일(예를 들어 객체 멤버 대신 포인터 멤버를 쓰는 일)은 코드를 더 느리고 더 복잡하게 만들 수 있다.
        * 전방 선언으로 얻어지는 실질적인 성능 개선은 증명된 적이 없다.
   * 결론
        * 헤더 파일에 선언된 함수를 사용할 때, 항상 그 헤더를 #include하라.
        * 클래스 템플릿을 사용할 때, 헤더 파일을 #include 하는 것을 선호하라.
        * 일반적인 클래스를 사용할 때 전방 선언에 의존하는 것은 괜찮으나 전방 선언이 불충분하거나 * 부정확한 경우를 조심하라. 고민되는 경우에는 그냥 적절한 헤더를 #include하라.
        * 단순히 #include를 피하기 위해서 데이터 멤버를 포인터로 대체하지 말라.
   * 항상 필요로 하는 선언 또는 정의를 실제로 제공하는 파일을 #include하라. 다른 헤더를 거쳐 간접적으로 가져온 기호에 의존하지 말라. 하나의 예외로 myfile.cpp 파일은 그에 상응하는 myfile.h 헤더에 있는 #include와 전방 선언에 의존할 수 있다.
3. 인라인 함수
   * 함수가 작을 때, 이를테면 10라인이나 그 이하일 정도일 때만 함수를 인라인으로 정의하라.
   * 정의
        * 일반적인 함수 호출 매커니즘으로 호출하는 대신 컴파일러가 해당 함수를 인라인 처리할 수 있도록 함수를 선언할 수 있다.
   * 장점
        * 함수가 짧다면, 인라인 함수는 더 효율적인 오브젝트 코드를 생성할 수 있다. 접근자나 변경자 혹은 다른 작은 함수, 성능에 결정적인 함수들을 인라인하는데 부담을 가지지 말라.
   * 단점
        * 인라인을 과도하게 사용하면 프로그램을 실제 더 느리게 만들 수 있다. 함수 크기에 따라서 인라인을 하면 함수 크기에 따라 코드 크기가 커질 수도, 작아질 수도 있다. 아주 작은 접근자 함수를 인라인하면 보통 코드 크기를 작게 하지만, 반면 매우 큰 함수를 인라인하게 되면 코드 크기를 엄청나게 크게 만들 수 있다. 최근의 프로세서들은 인스트럭션 캐쉬를 더욱 잘 활용하기 때문에 작은 코드가 더 빨리 돈다.
   * 결론
        * 괜찮은 판단방법은 길이가 10라인 이상인 함수는 인라인하지 않는 것이다. 소멸자를 주의하라! 소멸자는 함축적으로 멤버와 상위 클래스의 소멸자를 부르기 때문에 보이는 것보다 종종 길다.
        * 또 하나의 괜찮은 판단방법이 있다. 반복문이나 switch 문이 있는 함수 (보통의 경우 절대 수행되지 않는 반복문이나 switch 문인 경우를 제외하고)를 인라인하는 것은 보통 효과적이지 않다.
        * 함수가 인라인으로 선언되었다고 해서 항상 인라인되는 것은 아님을 유의하자. 예를 들면 가상 함수나 재귀 호출 함수는 보통 인라인되지 않는다. 일반적으로 재귀 호출 함수는 인라인되면 안 된다. 가상 함수를 인라인하는 이유는 접근자와 변경자의 경우처럼 주로 클래스 안에 정의를 넣기 위해서이며, 이는 편의 때문이거나, 하는 일을 문서화하기 위해서이다.
4. Inl.h 파일
   * 필요한 경우 복잡한 인라인 함수들을 정의하기 위해 Inl.h 접미어가 붙은 파일 이름을 사용할 수 있다.
   * 인라인 함수의 정의는 헤더 파일에 있어야 하며, 이것은 컴파일러가 인라인 함수 호출부분을 컴파일 할 때 인라인 함수의 정의가 필요하기 때문이다.
   * 하지만 구현 코드는 .cpp 파일에 포함되는 것이 적절하고, 가독성이나 성능상의 이점이 없는 경우 .h 파일에 실제 코드를 많이 넣는 것을 좋아하지 않는다.
   * 인라인 함수가 짧고 로직이 거의 없는 경우 .h 파일에 넣는 것이 좋다.
   * 예를 들면 접근자나 변경자들은 당연히 클래스 정의에 있어야 한다.
   * 구현이나 호출이 더 편리한 경우 더 복잡한 인라인 함수도 .h 파일에 넣을 수 있으나, 이들이 .h 파일을 너무 다루기 힘들게 만드는 경우엔 대신 별도의 Inl.h 파일에 코드를 넣을 수 있다.
   * 이는 클래스 정의와 인라인 함수의 구현을 분리하면서도 여전히 컴파일러가 필요할 때마다 인라인 함수의 구현을 사용할 수 있게 한다.
   * Inl.h 파일의 또 다른 사용은 함수 템플릿 정의를 위한 것이다. 이로써 템플릿 정의를 읽기 쉽도록 유지할 수 있다.
   * Inl.h 파일도 다른 모든 헤더 파일과 마찬가지로 #define 가드가 필요하다는 것을 잊지 말라.
5. 함수 인자 순서
   * 함수를 정의할 때 인자 순서는 입력이 먼저이고 출력이 다음이다.
   * C/C++ 함수의 인자는 입력이거나 출력이거나 둘 다일 수 있다.
   * 입력 인자는 보통 값(value)이거나 const 레퍼런스이고, 출력과 입출력 인자는 const가 아닌 포인터가 될 것이다.
   * 함수 인자를 순서에 따라 배열할 때, 모든 입력 전용 인자를 출력 인자보다 앞에 두라. 특히 단순히 새롭다는 이유로 새 인자를 함수 마지막에 추가하지 말라.
   * 새로운 입력 전용 인자가 있으면 출력 인자 앞에 두라.
   * 이것은 엄격한 규칙은 아니다.
   * 입력이면서 출력인 인자(종종 클래스와 구조체)는 일을 복잡하게 만든다.
   * 그리고 언제나 그렇듯이 관련된 함수들과의 일관성을 위해 이 규칙을 따르지 않을 수 있다.
6. include의 이름과 순서
   * 가독성을 높이고 숨겨진 종속성을 피하기 위해서 다음과 같은 순서를 사용하라.
   * C 라이브러리, C++ 라이브러리, 다른 라이브러리들의 .h, 현재 프로젝트의 .h.
   * 모든 프로젝트의 헤더 파일은 UNIX의 디렉터리 단축 표시인 . (현재 디렉터리)이나 .. (부모 디렉터리)을 사용하지 않고 프로젝트의 소스 디렉터리의 하위 요소로 나열되어야 한다.
   * ex) GoogleAwesomeProject/src/base/Logging.h는 이와 같이 #include되어야 한다.
   ``` C++
    #include "base/Logging.h"
   ```
   * 주된 목적이 dir2/Foo2.h에 있는 것들을 구현하거나 테스트하기 위한 dir/Foo.cpp나 dir/FooTest.cpp에서 include를 아래처럼 순서에 따라 배열하라.
      1. dir2/Foo2.h (아래 설명 참조).
      2. C 시스템 파일
      3. C++ 시스템 파일
      4. 다른 라이브러리의 .h 파일
      5. 현재 프로젝트의 .h 파일
   * 이 순서에 따르면 dir2/Foo2.h가 어느 필요한 include들을 빠뜨린 경우에 dir/Foo.cpp나 dir/FooTest.cpp의 빌드는 망가진다.
   * 그러므로 이 규칙은 다른 패키지에서 작업하는 무고한 사람들의 빌드 실패보다 이 파일에서 작업하는 사람들의 빌드 실패를 먼저 보여주도록 한다.
   * dir/Foo.cpp와 dir2/Foo2.h는 종종 같은 디렉터리에 있지만, 다른 디렉터리에 있을 수 있다
    ex) base/BasictypesTest.cpp, base/Basictypes.h
   * 각각의 부분 안에서 include는 알파벳 순서로 나열되어야 한다.
   * 오래된 코드는 이 규칙에 따르지 않을 수 있고 편리할 때 수정되어야 한다는 것에 주목하라.
   * 예를 들자면 GoogleAwesomeProject/src/foo/internal/Fooserver.cpp의 include들은 이렇게 보일 수 있다.
   ``` C++
   #include "foo/public/Fooserver.h"  // 바람직한 위치
   
   #include <sys/types.h>
   #include <unistd.h>
   #include <hash_map>
   #include <vector>
   
   #include "base/Basictypes.h"
   #include "base/CommandlineFlags.h"
   #include "foo/public/Bar.h"
   ```
   * 예외: 가끔 시스템에 특정한 코드들은 조건부 include를 필요로 한다.
   * 이런 코드들은 조건부 include를 다른 include 밑에 둘 수 있다.
   * 당연히, 시스템에 특정한 코드들을 작고 국한되게 유지하라.
   ``` C++
   #include "foo/public/FooServer.h"
   
   #include "base/Port.h"  // LANG_CXX11를 위해
   
   #ifdef LANG_CXX11
   #include <initializer_list>
   #endif  // LANG_CXX11
   ```