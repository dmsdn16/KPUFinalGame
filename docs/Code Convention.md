**C++ Style Guide**
=====
**배경**  
------
이 문서는 졸업작품 제작을 함에 있어서 코드 컨벤션을 사전에 지정함으로서 협업 중 혼선을 방지하는 것을 목표로 한다. 이 문서는 [Google C++ Style Guide](https://jongwook.kim/google-styleguide/trunk/cppguide.xml)를 참고해서 작성되었다.

**이름 규칙**
------
일관성을 위한 가장 중요한 규칙은 이름 규칙을 통제하는 것이다. 이름의 스타일을 통해 요소의 선언을 찾지 않고도 해당 요소가 타입인지, 변수인지, 함수인지, 상수인지, 혹은 매크로인지 바로 알 수 있다. 우리 머리 속의 패턴 매칭 엔진은 이러한 이름 규칙에 상당히 의존한다.
1. 일반 이름 규칙  
   *  함수 이름, 변수 이름, 파일 이름은 약어를 피하고 서술적으로 지어야 한다.
   *  가능하면 상세한 이름을 사용하라. 새로 읽는 사람이 즉시 이해할 수 있는 것이 글자 길이를 줄이는 것보다 훨씬 중요하다.
   *  프로젝트에 관계되지 않은 사람이 익숙하지 않은 약어를 사용하지 말고 중간 글자를 지워서 축약하지 말라.
2. 파일 이름
   * 파일 이름은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다.(CamelCased)  
    ex) MyUsefulClass.h, MyExcitingFunction.cpp
   * db.h와 같이 /usr/include에 이미 존재하는 파일 이름은 사용하지 말라.
   * 일반적으로 상세하게 파일 이름을 지으라.
    ex) HttpServerLogs.h가 logs.h보다 좋다.
   * 인라인 함수는 .h에 있어야 한다. 인라인 함수의 코드가 짧으면 .h안에 들어가고, 길다면 Inl.h로 가야한다. 클래스 안에 많은 인라인 코드가 있다면 3개의 파일로 분리한다. 
    ``` C++
    UrlTable.h          // 클래스 선언
    UrlTable.cpp        // 클래스 정의
    UrlTableInl.h       // 많은 코드를 포함한 인라인 함수
    ```
   * Inl.h 파일 섹션 참조
3. 타입 이름  
   * 타입 이름은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다.(CamelCased)  
    ex) MyExcitingClass, MyExcitingEnum
   * 타입 이름의 첫 글자로 타입의 이니셜을 대문자로 사용한다.
   * 클래스, 구조체, typedef, 열거형(enum)을 포함한 모든 타입에 대해 같은 규칙이 적용된다.
    ``` C++
    // 클래스와 구조체
    class CUrlTable {...}
    class CUrlTableProperties {...}
    struct CUrlTableProperties {...}

    // typedef
    typedef hash_map<UrlTableProperties*, std::string> HPPropertiesMap;
    
    // 열거형(enum)
    enum EUrlTableErrors {...}
    ```
4. 변수 이름  
    * 변수의 이름은 모두 소문자로 작성하며 단어 사이에 언더스코어를 사용한다.(under_scored)
    * 클래스 멤버 변수는 이름의 앞에 m_ 접두어를 사용한다.  
     ex) my_exciting_local_variable, m_my_exciting_member_variable  
   
    * 공통사항
        ``` C++
        std::string table_name; // 좋음 - 언더스코어를 사용한다.
        std::string tablename;  // 좋음 - 모두 소문자이다.

        std::string tableName;  // 불가 - 대문자 사용
        ```
    * 클래스 데이터 멤버
        * 데이터 멤버(인스턴스 변수 또는 멤버 변수)의 이름은 보통 변수처럼 소문자와 선택적인 언더스코어로 작성하지만, 항상 앞에 m_ 접두어를 붙인다.
        ``` C++
        std::string m_table_name;   // 좋음 - 앞에 m_가 있다.
        std::string m_tablename;    // 좋음
        ```
    * 구조체 변수
        * 구조체 안에 있는 데이터 멤버는 클래스에 있는 데이터 멤버와 다르게 앞에 m_ 접두어를 붙이지 않고 보통 변수처럼 이름짓는다.
        ``` C++
        struct UrlTableProperties
        {
            std::string name;
            int num_entries;
        }
        ```
        * 어떤 경우에 클래스와 구조체를 써야 할 지에 대해서는 구조체 대 클래스를 참고하라.  
    * 전역 변수
        * 제한적으로 사용되어야 하는 전역 변수의 이름에 대한 특별한 규칙은 없다. 하지만 전역 변수를 사용할 때에는 g_와 같이 로컬 변수와 쉽게 구분할 수 있는 접두어를 사용하는 것이 좋다.
5. 상수 이름
    * 지역변수인지, 전역변수인지, 클래스의 일부인지와 상관없이 모든 컴파일 시점 상수들은 다른 변수들과 조금 다른 이름 규칙을 사용한다. k로 시작하여 매 단어의 첫 글자를 대문자로 쓴다.(kCamelCased)
    ``` C++
    const int kDaysInWeek = 7;
    ```
6. 함수 이름  
    * 일반 함수들은 대문자로 시작하며 언더스코어 없이 단어마다 첫 글자로 대문자를 사용한다. 접근자와 변경자는 해당하는 변수의 이름과 같은 것을 쓴다.(CamelCased)  
     ex) MyExcitingFunction(), MyExcitingMethod()  
    
    * 일반 함수
        * 함수 이름은 대문자로 시작하여 각 단어의 첫 글자를 대문자로 쓰고, 언더스코어는 사용하지 않는다.
        * 함수의 실행 중 크래시가 발생할 수 있다면 함수의 이름 뒤에 OrDie를 붙인다. 이 규칙은 프로덕션 코드에서도 에러가 발생할 가능성이 어느 정도 있는 함수에 한해 적용한다.
        ``` C++
        AddTableEntry()
        DeleteUrl()
        OpenFileOrDie()
        ```
    * 접근자와 변경자
        * 접근자와 변경자 (get과 set 함수)는 접근 또는 변경을 하려는 변수의 이름과 일치하는 이름을 사용한다.
        ``` C++
        class MyClass
        {
        public:
        ...
            int NumEntries() const { return m_num_entries; }
            void SetNumEntries(int num_entries) { m_num_entries = num_entries; }

        private:
            int m_num_entries;
        };
        ```
7. 네임스페이스 이름  
    * 네임스페이스 이름은 모두 소문자로 하며, 프로젝트의 이름과 아마도 디렉토리 구조에 기반하여 작성한다.(under_scored)
     ex) kpu_final_game
    * 네임스페이스와 네임스페이스의 이름을 짓는 방식에 대해선 네임스페이스 섹션 참고.
8. 열거형 이름
    * 각각의 열거형은 상수처럼 이름짓는 것이 선호되지만 매크로처럼 이름짓는 것도 허용한다. 열거형의 이름은 타입이므로 대소문자를 섞어서 사용한다.(kCamelCased or ALL_CAPITALS)
    ``` C++
    enum UrlTableErrors
    {
        kOK = 0,
        kErrorOutOfMemory,
        kErrorMalformedInput,
    };
    enum AlternateUrlTableErrors
    {
        OK = 0,
        OUT_OF_MEMORY = 1,
        MALFORMED_INPUT = 2,
    };
    ```
    * 매크로 방식은 매크로와 열거형 값의 충돌을 일으켰고, 상수 스타일의 이름을 선호하는 방식으로 규칙이 변경되었다.
    * 매크로 방식의 이름이 실제로 컴파일 오류를 발생시키는 것이 아니라면 코드를 상수 스타일 이름으로 수정할 필요는 없다.
9. 매크로 이름
    * 전처리기 매크로 섹션을 참고하라.
    * 일반적으로 매크로는 사용하지 않는 것이 좋다.
    * 하지만 절대적으로 필요하다면 대문자와 언더스코어로만 이름을 짓는다.(ALL_CAPITALS)
    ``` C++
    #define ROUND(X) ...
    #define PI_ROUNDED 3.0
    ```
10. 이름 규칙의 예외
     * 이미 존재하는 C 또는 C++ 엔티티와 비슷한 것의 이름을 짓는 경우 그 이름 규칙을 따를 수 있다.
    ``` C++
    bigopen()
        open()의 이름에 기반한 함수
    uint
        typedef
    bigpos
        pos와 같은 형식의 struct 또는 class
    sparse_hash_map
        STL과 유사한 엔티티이므로 STL의 이름 규칙을 따름
    LONGLONG_MAX
        INT_MAX와 비슷한 상수
    ```

**포매팅**
-----
코딩 스타일과 포매팅은 제멋대로인 경우가 많지만, 모두가 통일된 스타일을 쓴다면 프로젝트를 파악하기가 훨씬 쉬워진다. 개개인이 모든 포매팅 규칙에 다 동의하기는 어렵고, 어떤 규칙은 익숙해지는데 시간이 걸리지만, 프로젝트의 구성원들이 규칙을 따라서 다른 사람의 코드를 쉽게 이해하도록 하는 것은 중요하다.
1. 함수 선언과 정의
   * 가능하면 리턴 타입과 함수 이름, 인자를 같은 줄에 작성하라.
   ``` C++
   ReturnType ClassName::FunctionName(Type par_name1, Type par_name2)
   {
        DoSomething();
        ...
   ```
   * 한 줄에 넣기에 글자가 너무 많다면
   ``` C++
   ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3)
   {
        DoSomething();
        ...
   }
   ```
   * 혹은 첫번째 인자도 맞추기 힘들다면
   ``` C++
   ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // Tab indent
    Type par_name2,
    Type par_name3)
   {
        DoSomething();  // Tab indent
        ...
   }
   ```
   * 몇 가지 주의할 점
     * 리턴 타입과 함수 이름을 한 줄에 적을 수 없다면, 그 사이를 줄바꿈하라.
     * 함수 정의의 리턴 타입 뒤에 줄바꿈을 한다면, 들여쓰기를 하지 말라.
     * 여는 괄호는 항상 함수 이름과 같은 줄에 작성하라.
     * 함수 이름과 여는 괄호 사이에는 절대로 스페이스를 넣지 않는다.
     * 괄호와 인자 사이에는 절대로 스페이스를 넣지 않는다.
     * 여는 중괄호({)는 마지막 인자의 다음 줄에 작성하거나, (다른 규칙들이 허용한다면) 인자와 같은 줄에 위치할 수 있다.
     * 닫는 중괄호(})는 혼자 마지막 줄에 위치하거나, (다른 규칙들이 허용한다면) 여는 중괄호와 같은 줄에 위치한다.
     * 모든 인자는 이름을 가져야 하며, 선언과 구현에서 같은 이름을 가지게 하라.
     * 모든 인자들은 가능한 한 정렬되어야 한다.
     * 기본 들여쓰기는 탭 스페이스이다.
     * 인자들이 다음 줄로 이동할 경우 탭 스페이스 들여쓰기를 사용한다.
   * 만약 몇몇 인자들이 사용되지 않으면, 함수 선언에서 변수 이름을 주석처리하라.
   ``` C++
   // 인터페이스에서는 항상 이름이 있는 인자를 가진다.
   class Shape
   {
    public:
        virtual void Rotate(double radians) = 0;
   }
   
   // 선언에서 항상 이름이 있는 인자를 가진다.
   class Circle : public Shape
   {
    public:
        virtual void Rotate(double radians);
   }
   
   // 정의에서 사용하지 않는 이름을 주석처리하라.
   void Circle::Rotate(double /*radians*/) {}

   // 나쁨 - 누군가 나중에 구현을 하려고 하더라도,
   // 변수가 무엇을 의미하는지 명확하게 알 수 없다.
   void Circle::Rotate(double) {}
   ```
2. 함수 호출
   * 함수 호출은 다음과 같은 형식으로 작성한다.
   ``` C++
   bool retval = DoSomething(argument1, argument2, argument3);
   ```
   * 인자들이 모두 한 줄에 들어갈 자리가 없다면 여러 줄로 나누어 쓰되 이어지는 줄은 첫번째 인자와 같은 열에 오도록 한다.
   * 여는 괄호 다음과 닫는 괄호 앞에는 스페이스를 추가하지 않는다.
   ``` C++
   bool retval = DoSomething(averyveryveryverylongargument1,
                             argument2, argument3);
   ```
   * 함수의 인자가 많은 경우 가독성을 위해 인자마다 한 줄씩 쓰는 것을 고려하라
   ``` C++
   bool retval = DoSomething(argument1,
                             argument2,
                             argument3,
                             argument4);
   ```
   * 모든 인자들마다 줄바꿈하여 한 줄에 하나씩 쓰는 것도 가능하다.
   ``` C++
   if (...)
   {
       ...
       ...
       if (...)
       {
            DoSomething(
                        argument1,
                        argument2,
                        argument3,
                        argument4);
   }
   ```
3. 중괄호 초기화 리스트
   * 중괄호로 된 초기화 리스트는 함수 호출에서와 완전히 같은 방식으로 작성한다.
   * 중괄호 리스트가 어떤 이름(타입이나 변수 이름)에 이어져서 사용되는 경우 {}가 그 이름을 가진 함수를 호출하는 괄호인 것처럼 작성한다.
   * 만약 그러한 이름이 없으면 길이가 0인 이름이 있다고 가정한다.
   ``` C++
   // 중괄호 초기화 리스트를 한 줄에 사용한 예
   return {foo, bar};
   functioncall({foo, bar});
   pair<int, int> p{foo, bar};
   
   // 줄바꿈을 해야 할 때
   SomeFunction(
           {"assume a zero-length name before {"},
            some_other_function_parameter);
   SomeType variable{
       some, other, values,
       {"assume a zero-length name before {"},
   SomeOtherType{
       "Very long string requiring the surrounding breaks.",
       some, other values},
        SomeOtherType{"Slightly shorter string",
                      some, other, values}};
        SomeType variable{
            "This is too long to fit all in one line"};
    MyType m = {  // 여기선 { 다음에도 줄바꿈을 할 수 있다
        superlongvariablename1,
        superlongvariablename2,
        {short, interior, list},
        {interiorwrappinglist,
         interiorwrappinglist2}};
   ```
4. 조건문
   * 괄호 안에서는 스페이스를 사용하지 않을 것을 권장한다.
   * else 키워드는 새 줄에서 사용한다.
   * 어떤 파일을 수정하고 있다면 그 파일에 이미 사용되고 있는 형식을 사용하라.
   * 새로운 코드를 작성하고 있다면 해당 디렉터리나 프로젝트의 다른 파일에서 사용하고 있는 형식을 사용하라.
   * 이미 사용되고 있는 형식을 알 수 없고 개인적인 선호도 없는 경우 스페이스를 넣지 말라.
   ``` C++
   if (condition)   // 괄호 안에 스페이스 없음
   {
       ...
   }
   else if (...)
   {
       ...
   }
   else
   {
       ...
   }
   ```
   * 일반적으로 한 줄짜리 구문의 경우 중괄호를 꼭 사용하지 않아도 되며, 선호하는 경우 사용하여도 된다.
   * 복잡한 조건이나 구문들로 이루어진 조건문과 반복문의 경우 중괄호가 있을 때 가독성이 더 좋을 수 있다.
   * 어떤 프로젝트는 if 문에 항상 중괄호를 사용할 것을 요구하기도 한다.
   ``` C++
   if (condition)
        DoSomething();
   ```
   * 하지만 만약 if-else 문 중 한 쪽이 중괄호를 사용하고 있다면 다른 쪽도 반드시 사용해야 한다.
   ``` C++
   // 안됨 - IF에는 중괄호가 있지만 ELSE에는 없음
   if (condition)
   {
       foo;
   }
   else
       bar;
   // 안됨 - ELSE에는 중괄호가 있지만 IF에는 없음
   if (condition)
        foo;
   else
   {
        bar;
   }

   // 한 쪽에 중괄호를 사용하였으면 IF 와 ELSE 모두 중괄호가 있어야 함
   if (condition)
   {
       foo;
   }
   else
   {
        bar;
   }
   ```
5. 반복문과 switch문
   * switch 문은 블록마다 중괄호를 사용할 수 있다.
   * 단순하지 않게 이어지는 case 문들은 주석을 달아야 한다.
   * 비어 있는 반복문은 {} 또는 continue를 사용해야 한다.
   * switch문의 case 블록은 선호에 따라 중괄호를 사용할 수도 있고 그렇지 않을 수 있다.
   * 중괄호를 사용하는 경우엔 아래와 같은 위치에 사용해야 한다.
   * 열거형 값에 대한 조건이 아닌 경우, switch 문은 항상 default 케이스를 포함하는 것이 좋다.(열거형의 경우 처리하지 않은 값에 대해 컴파일러가 경고할 것이다.)
   * 만약 default 케이스가 실행되지 말아야 할 경우 간단히 assert하라.






**주석**
-----
작성하는 것이 쉽지 않지만, 주석은 코드의 가독성을 유지하는 데 절대적으로 중요한 역할을 한다. 다음 규칙은 어디에 무엇을 주석으로 달아야 할 지를 설명한다. 하지만 기억할 점은 주석은 매우 중요하지만, 가장 좋은 코드는 스스로에 대해 설명을 할 수 있는 코드라는 것이다. 타입과 변수에 이해할 수 있는 이름을 짓는 것이 이상한 이름을 짓고 주석으로 설명하는 것보다 훨씬 좋다. 주석을 작성할 때에는 주석을 읽는 이를 위해서, 즉 그 코드를 보고 이해해야 하는 다음 작업자를 위해 작성하라. 관대함을 가지라 - 다음 작업자는 본인일 수도 있다!
1. 주석 스타일
   * // 문법을 사용한다.
   * 주석의 내용과 위치, 작성 방식에 일관성이 있어야 한다.
2. 파일 주석
   * 모든 파일의 위쪽에는 파일의 내용을 설명하는 주석이 포함되어야 한다.
   * 일반적으로 .h 파일은 그 파일 안에 정의된 클래스에 대한 설명와 그 클래스가 어떻게 사용되는지에 대한 설명을 포함해야 한다.
   * .cpp 파일은 구현에 대한 세부사항이나 다루기 힘든 알고리즘에 대한 논의를 담아야 한다.
   * 구현 세부사항이나 알고리즘에 대한 논의가 .h 파일을 읽는 사람에게도 필요하다고 생각하면 헤더 파일에 넣을 수도 있으나, .cpp에도 이에 대한 문서가 .h 파일에 있다는 것을 명시해야 한다.
   * .h와 .cpp에 중복하여 주석을 사용하지 말라.
   * 중복된 주석은 서로 다르게 변화할 것이다.
3. 클래스 주석
   * 모든 클래스 정의는 그것이 무엇이고 어떻게 사용하는 지 설명하는, 클래스에 수반하는 주석을 가져야 한다.
   ``` C++
   // GargantuanTable의 내용을 이터레이트한다.
   // 용례:
   //    GargantuanTableIterator* iter = table->NewIterator();
   //
   //    for (iter->Seek("foo"); !iter->done(); iter->Next())
   //    {
   //       process(iter->key(), iter->value());
   //    }
   //
   //    delete iter;
   class GargantuanTableIterator
   {
     ...
   };
   ```
   * 이미 파일 상단의 주석에 클래스에 대한 상세한 설명을 두었다면, "전체 설명을 보기 위해서 파일 상단을 보라"라고 부담 없이 적어도 된다.
   * 단 어떤 형태로든 주석이 있어야 한다.
   * 클래스가 가정하고 있는 동기화 가정이 있는 경우 그것을 설명하라.
   * 만약 클래스의 인스턴스에 여러 개의 스레드에서 접근할 수 있는 경우, 멀티 스레드 사용을 둘러싼 규칙과 변하지 않는 사항을 설명하는 데 특별히 주의를 기울이라.
4. 함수 주석
   * 선언 주석은 함수의 사용을 설명한다. 함수 정의의 주석은 함수의 동작을 설명한다.
   * 함수 선언
       * 모든 함수 선언은 그 함수가 무엇이고 어떻게 사용하는지 설명하는, 바로 직전에 위치한 주석을 가져야 한다.
       * 이 주석은 명령문("파일을 열어라")이 아니라 설명문("파일을 연다")이어야 한다.
       * 주석은 함수를 설명하는 것이지, 함수에게 무엇을 하라고 말하는 것이 아니다.
       * 보통 이 주석은 함수가 어떻게 그 작업을 수행하는지 설명하지 않는다.
       * 대신 이 내용은 함수 정의의 주석에게 넘겨져야 한다.
       * 함수 선언의 주석에서 언급되어야 하는 것들의 유형은
            * 입력은 무엇이고 출력은 무엇인지.
            * 클래스 멤버 함수의 경우 객체가 레퍼런스 인자를 메서드 호출이 끝난 후에도 기억하는지, 객체가 레퍼런스 인자를 해제하는지, 해제하지 않는지.
            * 함수가 메모리를 할당하는 경우, 호출자가 해제해야 하는지.
            * 인자 중 어떤 것이 null 포인터일 수 있는지.
            * 함수가 사용에 있어 어떤 성능 상의 영향이 있는 경우.
            * re-entrant한 함수의 경우 동기화에 대한 가정이 무엇인지.
       ``` C++
       // 이 테이블에 대한 반복자를 반환한다. 사용이 끝난 후 이터레이터
       // 삭제는 클라이언트의 책임이며, 반복자가 만들어진
       // GargantuanTable 객체가 삭제된 후 반복자를 사용하면 안 된다.
       //
       // 반복자는 최초에 테이블의 시작에 위치한다.
       //
       // 이 메서드는 아래와 동일하다.
       //    Iterator* iter = table->NewIterator();
       //    iter->Seek("");
       //    return iter;
       // 반환된 반복자와 다른 장소를 즉시 찾고자 하는 경우,
       // NewIterator()를 사용하면 더 빠르고, 추가로 검색이 일어나지 않는다.
       Iterator* GetIterator() const;
       ```
       *  하지만 필요 이상으로 자세하거나 완벽하게 명백하도록 서술하지 말라.
       *  아래에서 "그렇지 않은 경우 false를 반환한다"고 말하는 것은 이미 함축된 것이기에 불필요하다는 점에 주목하라.
       ``` C++
       // 테이블이 더 이상 엔트리를 가질 수 없을 때 true를 반환한다.
       bool IsTableFull();
       ```
       * 생성자와 소멸자에 주석을 달 때, 그 코드를 읽는 사람은 생성자와 소멸자가 무엇을 위한 것인지 알고 있음을 기억하라.
       * 그러므로 단지 "이 객체를 소멸시킨다" 따위의 것을 쓰는 것은 쓸모가 없다.
       * 생성자가 그의 인자로 무엇을 하는지 설명하고 (예를 들면 그들이 포인터의 소유권을 가지는 경우), 소멸자가 무엇을 해제하는 지 설명하라.
       * 설명이 사소한 경우 그냥 주석을 생략하라.
       * 소멸자가 헤더 주석을 가지지 않는 경우는 상당히 흔하다.
   * 함수 정의
       * 함수가 작업을 수행하는 방법 상 까다로운 부분이 있는 경우, 함수 정의가 설명하는 주석을 가져야 한다.
       * 예를 들면 그 코드에서 사용하는 코딩 비결을 설명하거나, 함수 안에서 수행하는 작업 절차에 대한 개요를 제시하거나, 왜 가능한 다른 대안을 사용하지 않고 특정한 방식으로 함수를 구현했는지 함수 정의에서 설명할 수 있다.
       * 예를 들면 함수의 전반부에는 lock을 획득하지만 후반부에서는 lock이 필요없는 이유를 언급할 수 있다.
       * .h 파일이나 혹은 어딘가에 있을, 함수 선언의 주석을 단지 반복하지 않아야 하는 데 주목하라.
       * 함수가 무엇을 하는지 요약하여 요점을 되풀이하는 것은 문제 없으나, 주석의 요점은 함수가 그것을 어떻게 수행하느냐에 대한 것이어야 한다.
5. 변수 주석
   * 일반적으로 변수의 실제 이름은 그 변수가 무엇을 위한 것인지 알아채기 쉽도록 설명적이어야 한다.
   * 어떤 경우에는 더 많은 주석이 필요하다.
   * 클래스 데이터 멤버
       * (인스턴스 변수나 멤버 변수라고도 불리는) 각각의 클래스 데이터 멤버는 그것이 무엇을 위한 것인지 설명하는 주석을 가져야 한다.
       * 만약 변수가 null 포인터나 -1과 같은, 특별한 의미의 표식 값을 가질 수 있는 경우 이를 설명해야 한다.
       ``` C++
       private:
       // 테이블에 있는 엔트리의 총 개수를 기록한다.
       // 한계를 넘지 않도록 보장하는 데 사용된다. -1은 테이블에 얼마나 많은
       // 엔트리가 들어있는지 아직 알지 못하는 경우를 의미한다.
       int num_total_entries_;
       ```
   * 전역 변수
       * 데이터 멤버와 마찬가지로, 모든 전역 변수는 그것이 무엇이며 어디에 사용되는지 설명하는 주석을 가져야 한다.
       ``` C++
       private:
       // 이 회귀 테스트에서 통과한 테스트 케이스의 총 개수
       const int kNumTestCases = 6;
       ```
6. 구현 주석
   * 구현에서 까다롭거나, 명백하지 않거나, 흥미롭거나, 중요한 부분은 주석을 가져야 한다.
   * 클래스 데이터 멤버
       * 까다롭거나 복잡한 코드 조각은 그 앞에 주석을 포함해야 한다.
       ``` C++
       // 덧셈에서 생긴 carry를 고려하여 결과를 2로 나눈다.
       // (역자 주: 큰 숫자를 2로 나누는 알고리즘으로 나눗셈을 비트 연산으로
       // 처리하되 나눠지지 않는 큰 숫자의 나머지를 carry로 보아 다음
       // 나눗셈에 해당하는 비트 연산으로 전달하는 코드이다.)
       for (int i = 0; i < result->size(); i++)
       {
            x = (x << 8) + (*result)[i];
            (*result)[i] = x >> 1;
            x &= 1;
       }
       ```
   * 줄 주석
       * 또한 명백하지 않은 부분도 줄 끝에 주석을 가져야 한다.
       * 이러한 줄 끝 주석은 2개의 스페이스 문자로 코드에서 분리되어야 한다.
       ``` C++
       // 덧셈에서 생긴 carry를 고려하여 결과를 2로 나눈다.
       mmap_budget = max<int64>(0, mmap_budget - index_->length());
       if (mmap_budget >= data_size_ && !MmapData(mmap_chunk_bytes, mlock))
            return;  // 오류는 이미 로그에 기록되었다.
       ```
       * 코드가 무엇을 하고 있는지 설명하는 주석과 함수가 리턴할 때 오류가 이미 로그에 기록되었음을 언급하는 주석이 모두 있음에 주목하라.
       * 다음 줄에 여러 주석이 있는 경우, 종종 이들을 일렬로 세우는 것이 더 읽기 쉬울 수 있다.
       ``` C++
       DoSomething();                  // 주석을 일렬로 세우기 위해 여기에 주석을 둔다.
       DoSomethingElseThatIsLonger();  // 코드와 주석 사이에 두 스페이스가 있기 때문에
                                       // 여기에 주석을 둔다.
       { // 새 범위가 시작될 경우 주석 앞에 스페이스를 하나 두는 것이 허용되고,
         // 이에 따라 따라오는 주석과 코드에 일렬로 세워진다.
         DoSomethingElse();  // 줄 주석의 앞에는 보통 두 개의 스페이스
       }
       DoSomething(); /* 뒤따르는 블럭 주석에는 하나의 스페이스면 충분하다. */
       ```
   * nullptr/NULL, true/false, 1, 2, 3...
       * null 포인터나 boolean 혹은 문자로 된 숫자 값을 함수에 전달할 때, 그것들이 무엇인지에 관해 주석을 추가하거나 상수를 사용하여 코드가 스스로 설명될 수 있게 만들어야 한다.
       ``` C++
       // 안 좋은 예
       bool success = CalculateSomething(interesting_value,
                                         10,
                                         false,
                                         NULL);  // 이 인자들은 무엇일까?
       // 올바른 예
       bool success = CalculateSomething(interesting_value,
                                         10,     // 디폴트 기본값.
                                         false,  // 호출이 최초가 아님.
                                         NULL);  // 콜백 없음.

       // 스스로 설명할 수 있는 변수나 상수들을 사용한 예
       const int kDefaultBaseValue = 10;
       const bool kFirstTimeCalling = false;
       Callback *null_callback = NULL;
       bool success = CalculateSomething(interesting_value,
                                         kDefaultBaseValue,
                                         kFirstTimeCalling,
                                         null_callback);
       ```
   * 하지 말 것
       * 절대로 코드 그 자체를 설명하지 말아야 한다는 데 주목하라.
       * 코드를 읽는 사람이 코드의 의도를 모름에도 불구하고 코드 작성자보다 C++을 더 잘 알고 있다고 가정하라.
       ``` C++
       // 이제 b 배열을 통과하는데 만약 i가 있다면 다음 요소는 i+1임이 확실하다.
       ...        // 이런, 이 얼마나 쓸데없는 주석인가.
       ```
7. 구두점, 철자, 문법
   * 구두점, 철자, 문법에 주의하라.
   * 구두점, 철자, 문법이 제대로 사용된 주석이 이해하기 쉽다.
   * 주석은 일반적인 문장과 마찬가지로 읽기가 쉬워야 하고, 적절한 대소문자와 구두점이 사용되어야 한다.
   * 대부분의 경우 완전한 문장이 파편화된 문장에 비해 이해하기가 쉽다.
   * 코드 라인의 끝에 사용되는 주석은 격식을 갖추지 못할 수도 있지만 일관성은 있어야 한다.
   * 세미콜론을 사용해야 할 자리에 콤마를 사용했다고 코드 리뷰어에게 지적당하는 현실에 좌절할 수도 있지만, 소스코드는 높은 수준의 명확함과 가독성을 유지해야 한다.
   * 올바른 구두점, 철자, 문법의 사용은 그 목표를 달성하는데 도움을 준다.
8. TODO 주석
   * 아직 완벽하지 않은 코드 혹은 임시적이고 단기적인 해결책에 TODO 주석을 사용하라.
   * TODO 주석에서 TODO는 모두 대문자로 해야 하며, 이름, 이메일 혹은 다른 종류의 작성자를 판별할 수 있는 방법을 제공하여 문제점을 문의할 수 있도록 해야 한다.
   * 콜론은 선택적으로 사용할 수 있다.
   * 일관성 있는 TODO 포맷을 사용하여 필요할 때 올바른 상황 설명을 해 줄 사람을 찾을 수 있게 하는 것이 주 목적이다.
   * TODO 주석은 작성자가 그 문제를 고친다는 약속은 아니다.
   * 그러므로 TODO 주석에 언제나 이름을 포함하라.
   ``` C++
   // TODO(kl@gmail.com): 연결 연산자로 "*"를 사용하라.
   // TODO(Zeke) 연관 관계를 사용하도록 이 부분을 수정.
   ```
   * TODO 주석의 형태가 "미래에 무엇을 한다"라면, 상세한 날짜를 남기거나 ("2005년 11월까지 수정"), 상세한 이벤트를 기록하라 (모든 클라이언트가 XML 응답을 할 수 있게 되면 삭제).
9. Deprecation 주석
   * Deprecate된 인터페이스는 DEPRECATED 주석으로 표시해 둔다.
   * DEPRECATED 를 모두 대문자로 쓴 주석을 사용하여 deprecate된 인터페이스를 표시할 수 있다.
   * 주석은 인터페이스가 선언된 윗 라인이나 같은 라인에 쓰면 된다.
   * DEPRECATED 뒤에 이름, 이메일 혹은 다른 식별자를 괄호 안에 쓴다.
   * DEPRECATED 주석은 호출측의 문제점을 수정할 수 있도록 간결하고 명확하게 작성하여야 한다.
   * C++에서는 deprecate된 함수를 인라인으로 구현하여 새 인터페이스를 호출하게 할 수 있다.
   * DEPRECATED 주석을 표시한다고 해서 호출 측의 문제가 자동으로 수정되는 것은 아니다.
   * 호출측의 코드를 직접 수정하거나 다른 사람을 시켜서 deprecate된 인터페이스를 사용하지 않도록 조치를 취해야 한다.
   * 새로 작성하는 코드는 deprecate된 인터페이스를 사용하지 말고, 새로운 인터페이스를 사용해야 한다.
   * deprecate된 인터페이스를 대체할 인터페이스를 모를 경우에는 deprecate 주석을 작성한 사람에게 새로운 인터페이스를 문의해서 사용해야 한다.

**헤더 파일**
------
기본적으로 모든 .cpp 파일은 수반된 .h 파일을 가져야 한다. 흔한 예외로는 유닛 테스트나 main() 함수만을 가진 작은 .cpp 파일 등이 있다. 헤더 파일을 바르게 사용하는 것으로 코드의 가독성과 크기와 성능에 큰 차이를 만들 수 있다. 아래 규칙들은 헤더 파일을 사용할 때 피해야 할 함정들에 관한 가이드이다.
1. #define 가드
   * 모든 헤더 파일은 여러 번 포함되지 않기 위해 #define 가드를 사용해야 한다. 기호의 포맷은 <PROJECT>_<PATH>_<FILE>_H_ 으로 한다.
   * 유일성을 보장하기 위해 #define 가드는 프로젝트의 소스 트리의 절대 경로에 기반해야 한다. 예를 들어 프로젝트에 foo/src/bar/Baz.h 파일이 있다면 foo는 아래와 같은 가드를 가져야 한다.
    ``` C++
    #ifndef FOO_BAR_BAZ_H_
    #define FOO_BAR_BAZ_H_
    ...
    #endif  // FOO_BAR_BAZ_H_
    ```
   * 이를 대체하는 대체제로 #pragma once를 사용할 수 있지만 pragma 키워드는 Visual Studio에 종속적인 키워드라 다른 IDE에서 작동을 안 하므로 범용성을 보장하고자 하면 위와 같은 절차를 따르는 것이 좋다.
2. 전방 선언
   * 불필요한 #include를 피하기 위해 클래스를 전방 선언할 수도 있다.
   * 정의
        * "전방 선언"이란 수반되는 정의 없이 클래스나 함수, 템플릿을 선언하는 것이다. 클라이언트 코드에서 어떤 기호가 실제로 사용되든 #include 라인은 종종 전방 선언으로 대체할 수 있다.
   * 장점
        * 불필요한 #include는 컴파일러가 더 많은 파일을 열고 더 많은 입력을 처리하도록 만든다.
        * 불필요한 #include는 헤더 파일 변경 시 코드를 더 자주 다시 컴파일하도록 만든다.
   * 단점
        * 템플릿, typedef, 디폴트 인자, using 선언과 같은 기능을 쓸 때 전방 선언의 정확한 형태를 결정하기 힘들 수 있다.
        * 어떤 코드 조각에서는 전방 선언이 필요한지 전체 #include가 필요한지 결정하기 힘들 수 있다. 특히 암시적 변환이 개입될 때 그렇다. 극단적인 경우에는 #include를 전방 선언으로 대체하면 코드의 의미가 조용히 바뀔 수도 있다.
        * 헤더에서 여러 기호를 전방 선언하는 것은 단순히 헤더를 #include하는 것보다 장황해질 수 있다.
        * 호환성을 깨지 않고 헤더에서 할 수 있었던 변경들이 함수나 템플릿의 전방 선언 때문에 불가능해질 수 있다. 예를 들어 인자 타입을 더 넓은 타입으로 바꾼다거나, 디폴트 값이 있는 템플릿 인자를 추가하는 것 등이 그렇다.
        * std:: 네임스페이스의 기호를 전방 선언하면 보통 예상할 수 없는 결과를 유발한다.
        * 전방 선언이 가능하도록 코드를 구조화하는 일(예를 들어 객체 멤버 대신 포인터 멤버를 쓰는 일)은 코드를 더 느리고 더 복잡하게 만들 수 있다.
        * 전방 선언으로 얻어지는 실질적인 성능 개선은 증명된 적이 없다.
   * 결론
        * 헤더 파일에 선언된 함수를 사용할 때, 항상 그 헤더를 #include하라.
        * 클래스 템플릿을 사용할 때, 헤더 파일을 #include 하는 것을 선호하라.
        * 일반적인 클래스를 사용할 때 전방 선언에 의존하는 것은 괜찮으나 전방 선언이 불충분하거나 * 부정확한 경우를 조심하라. 고민되는 경우에는 그냥 적절한 헤더를 #include하라.
        * 단순히 #include를 피하기 위해서 데이터 멤버를 포인터로 대체하지 말라.
   * 항상 필요로 하는 선언 또는 정의를 실제로 제공하는 파일을 #include하라. 다른 헤더를 거쳐 간접적으로 가져온 기호에 의존하지 말라. 하나의 예외로 myfile.cpp 파일은 그에 상응하는 myfile.h 헤더에 있는 #include와 전방 선언에 의존할 수 있다.
3. 인라인 함수
   * 함수가 작을 때, 이를테면 10라인이나 그 이하일 정도일 때만 함수를 인라인으로 정의하라.
   * 정의
        * 일반적인 함수 호출 매커니즘으로 호출하는 대신 컴파일러가 해당 함수를 인라인 처리할 수 있도록 함수를 선언할 수 있다.
   * 장점
        * 함수가 짧다면, 인라인 함수는 더 효율적인 오브젝트 코드를 생성할 수 있다. 접근자나 변경자 혹은 다른 작은 함수, 성능에 결정적인 함수들을 인라인하는데 부담을 가지지 말라.
   * 단점
        * 인라인을 과도하게 사용하면 프로그램을 실제 더 느리게 만들 수 있다. 함수 크기에 따라서 인라인을 하면 함수 크기에 따라 코드 크기가 커질 수도, 작아질 수도 있다. 아주 작은 접근자 함수를 인라인하면 보통 코드 크기를 작게 하지만, 반면 매우 큰 함수를 인라인하게 되면 코드 크기를 엄청나게 크게 만들 수 있다. 최근의 프로세서들은 인스트럭션 캐쉬를 더욱 잘 활용하기 때문에 작은 코드가 더 빨리 돈다.
   * 결론
        * 괜찮은 판단방법은 길이가 10라인 이상인 함수는 인라인하지 않는 것이다. 소멸자를 주의하라! 소멸자는 함축적으로 멤버와 상위 클래스의 소멸자를 부르기 때문에 보이는 것보다 종종 길다.
        * 또 하나의 괜찮은 판단방법이 있다. 반복문이나 switch 문이 있는 함수 (보통의 경우 절대 수행되지 않는 반복문이나 switch 문인 경우를 제외하고)를 인라인하는 것은 보통 효과적이지 않다.
        * 함수가 인라인으로 선언되었다고 해서 항상 인라인되는 것은 아님을 유의하자. 예를 들면 가상 함수나 재귀 호출 함수는 보통 인라인되지 않는다. 일반적으로 재귀 호출 함수는 인라인되면 안 된다. 가상 함수를 인라인하는 이유는 접근자와 변경자의 경우처럼 주로 클래스 안에 정의를 넣기 위해서이며, 이는 편의 때문이거나, 하는 일을 문서화하기 위해서이다.
4. Inl.h 파일
   * 필요한 경우 복잡한 인라인 함수들을 정의하기 위해 Inl.h 접미어가 붙은 파일 이름을 사용할 수 있다.
   * 인라인 함수의 정의는 헤더 파일에 있어야 하며, 이것은 컴파일러가 인라인 함수 호출부분을 컴파일 할 때 인라인 함수의 정의가 필요하기 때문이다.
   * 하지만 구현 코드는 .cpp 파일에 포함되는 것이 적절하고, 가독성이나 성능상의 이점이 없는 경우 .h 파일에 실제 코드를 많이 넣는 것을 좋아하지 않는다.
   * 인라인 함수가 짧고 로직이 거의 없는 경우 .h 파일에 넣는 것이 좋다.
   * 예를 들면 접근자나 변경자들은 당연히 클래스 정의에 있어야 한다.
   * 구현이나 호출이 더 편리한 경우 더 복잡한 인라인 함수도 .h 파일에 넣을 수 있으나, 이들이 .h 파일을 너무 다루기 힘들게 만드는 경우엔 대신 별도의 Inl.h 파일에 코드를 넣을 수 있다.
   * 이는 클래스 정의와 인라인 함수의 구현을 분리하면서도 여전히 컴파일러가 필요할 때마다 인라인 함수의 구현을 사용할 수 있게 한다.
   * Inl.h 파일의 또 다른 사용은 함수 템플릿 정의를 위한 것이다. 이로써 템플릿 정의를 읽기 쉽도록 유지할 수 있다.
   * Inl.h 파일도 다른 모든 헤더 파일과 마찬가지로 #define 가드가 필요하다는 것을 잊지 말라.
5. 함수 인자 순서
   * 함수를 정의할 때 인자 순서는 입력이 먼저이고 출력이 다음이다.
   * C/C++ 함수의 인자는 입력이거나 출력이거나 둘 다일 수 있다.
   * 입력 인자는 보통 값(value)이거나 const 레퍼런스이고, 출력과 입출력 인자는 const가 아닌 포인터가 될 것이다.
   * 함수 인자를 순서에 따라 배열할 때, 모든 입력 전용 인자를 출력 인자보다 앞에 두라. 특히 단순히 새롭다는 이유로 새 인자를 함수 마지막에 추가하지 말라.
   * 새로운 입력 전용 인자가 있으면 출력 인자 앞에 두라.
   * 이것은 엄격한 규칙은 아니다.
   * 입력이면서 출력인 인자(종종 클래스와 구조체)는 일을 복잡하게 만든다.
   * 그리고 언제나 그렇듯이 관련된 함수들과의 일관성을 위해 이 규칙을 따르지 않을 수 있다.
6. include의 이름과 순서
   * 가독성을 높이고 숨겨진 종속성을 피하기 위해서 다음과 같은 순서를 사용하라.
   * C 라이브러리, C++ 라이브러리, 다른 라이브러리들의 .h, 현재 프로젝트의 .h.
   * 모든 프로젝트의 헤더 파일은 UNIX의 디렉터리 단축 표시인 . (현재 디렉터리)이나 .. (부모 디렉터리)을 사용하지 않고 프로젝트의 소스 디렉터리의 하위 요소로 나열되어야 한다.
   * ex) GoogleAwesomeProject/src/base/Logging.h는 이와 같이 #include되어야 한다.
   ``` C++
    #include "base/Logging.h"
   ```
   * 주된 목적이 dir2/Foo2.h에 있는 것들을 구현하거나 테스트하기 위한 dir/Foo.cpp나 dir/FooTest.cpp에서 include를 아래처럼 순서에 따라 배열하라.
      1. dir2/Foo2.h (아래 설명 참조).
      2. C 시스템 파일
      3. C++ 시스템 파일
      4. 다른 라이브러리의 .h 파일
      5. 현재 프로젝트의 .h 파일
   * 이 순서에 따르면 dir2/Foo2.h가 어느 필요한 include들을 빠뜨린 경우에 dir/Foo.cpp나 dir/FooTest.cpp의 빌드는 망가진다.
   * 그러므로 이 규칙은 다른 패키지에서 작업하는 무고한 사람들의 빌드 실패보다 이 파일에서 작업하는 사람들의 빌드 실패를 먼저 보여주도록 한다.
   * dir/Foo.cpp와 dir2/Foo2.h는 종종 같은 디렉터리에 있지만, 다른 디렉터리에 있을 수 있다
    ex) base/BasictypesTest.cpp, base/Basictypes.h
   * 각각의 부분 안에서 include는 알파벳 순서로 나열되어야 한다.
   * 오래된 코드는 이 규칙에 따르지 않을 수 있고 편리할 때 수정되어야 한다는 것에 주목하라.
   * 예를 들자면 GoogleAwesomeProject/src/foo/internal/Fooserver.cpp의 include들은 이렇게 보일 수 있다.
   ``` C++
   #include "foo/public/Fooserver.h"  // 바람직한 위치
   
   #include <sys/types.h>
   #include <unistd.h>
   #include <hash_map>
   #include <vector>
   
   #include "base/Basictypes.h"
   #include "base/CommandlineFlags.h"
   #include "foo/public/Bar.h"
   ```
   * 예외: 가끔 시스템에 특정한 코드들은 조건부 include를 필요로 한다.
   * 이런 코드들은 조건부 include를 다른 include 밑에 둘 수 있다.
   * 당연히, 시스템에 특정한 코드들을 작고 국한되게 유지하라.
   ``` C++
   #include "foo/public/FooServer.h"
   
   #include "base/Port.h"  // LANG_CXX11를 위해
   
   #ifdef LANG_CXX11
   #include <initializer_list>
   #endif  // LANG_CXX11
   ```